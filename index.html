<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Foto con Marco ‚Äì Generador</title>
  <style>
    :root{--bg:#ffffff;--panel:#ffffff;--accent:#a1007d;--muted:#a1007d;--text:#a1007d}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,Segoe UI Emoji; background:linear-gradient(180deg,#ffffff,#ffffff 30%,#d5d5d5);color:var(--text);}
    .wrap{max-width:980px;margin:24px auto;padding:16px}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:16px}
    h1{font-size:clamp(18px,2.5vw,26px);margin:0;font-weight:700;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:.95rem}
    .card{background:rgb(255, 255, 255);backdrop-filter:saturate(160%) blur(6px);border:1px solid rgb(255, 255, 255);border-radius:16px;padding:14px}
    .grid{display:grid;grid-template-columns:1fr;gap:14px}
    @media(min-width:900px){.grid{grid-template-columns:360px 1fr}}
    canvas{width:100%;aspect-ratio:1/1;border-radius:14px;background:#ffffff;border:1px solid rgba(255, 255, 255, 0);touch-action:none}
    .controls{display:grid;gap:10px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{font-size:.9rem;color:var(--muted)}
    input[type="file"],input[type="text"],select,button{background:#eeeeee;border:1px solid rgb(212, 212, 212);color:var(--text);padding:10px 12px;border-radius:12px;font-size:.95rem}
    input[type="text"]{width:100%}
    input[type="range"]{width:220px}
    .btn{cursor:pointer;border:1px solid rgb(212, 212, 212)}
    .btn.primary{background:linear-gradient(180deg,#a1007d,#660053);color:#ffffff;border:none}
    .btn.ghost{background:transparent}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid rgba(148,163,184,.25);color:var(--muted);font-size:.85rem}
    .tip{font-size:.85rem;color:var(--muted)}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:#ffffff;border:1px solid rgba(148,163,184,.35);padding:2px 6px;border-radius:6px}
    .divider{height:1px;background:linear-gradient(90deg,transparent,rgba(161, 0, 125, 0.956),transparent);margin:6px 0 2px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1 id="title">Generador de foto con marco Bag√≥</h1>
        <div class="sub">Sube una foto, se aplica el marco y desc√°rgala lista (1080√ó1080). Arrastra para mover, rueda/pellizca para zoom.</div>
      </div>
    </header>

    <div class="grid">
      <div class="card">
        <canvas id="preview" width="540" height="540" aria-label="Lienzo de previsualizaci√≥n"></canvas>
        <div class="row" style="margin-top:10px;justify-content:space-between">
          <div class="tip">Consejo: Usa una foto donde se vizualice el rostro claramemte y con buena iluminaci√≥n. </div>
          <button class="btn ghost" id="resetBtn">Reiniciar</button>
        </div>
      </div>

      <div class="card controls">
        <div class="row">
          <label for="photoInput">üì∑ Cargar foto</label>
          <input type="file" id="photoInput" accept="image/*" />
        </div>

        <div class="divider"></div>
        <div class="row">
          <label>üß≠ Ajuste</label>
          <button class="btn" id="fitBtn" title="Ajustar la foto para que quepa completa">Encajar</button>
          <button class="btn" id="fillBtn" title="Rellenar el lienzo sin bordes">Rellenar</button>
        </div>

        <div class="row">
    <label for="zoomRange">üîç Zoom</label>
    <input id="zoomRange" type="range" min="0.2" max="4" step="0.01" value="1" />
  </div>

  <div class="row">
    <label for="rotateRange">‚Üª Rotar</label>
    <input id="rotateRange" type="range" min="-80" max="80" step="0.1" value="0" />
  </div>

        <div class="row">
          <button class="btn primary" id="downloadBtn">‚¨á Descargar PNG (1080√ó1080)</button>
        </div>


      </div>
    </div>
  </div>

  <script>
    // ========= Utilidades =========
    const $ = sel => document.querySelector(sel);
    const params = new URLSearchParams(location.search);

    // ========= Estado =========
    const state = {
      canvasSize: 540,            // preview canvas size (px)
      exportSize: 1080,           // output size (px)
      photo: null,                // HTMLImageElement
      frame: null,                // HTMLImageElement (PNG con transparencia recomendado)
      zoom: 1,
      rotation: 0,                // en grados
      offset: {x: 0, y: 0},       // desplazamiento de la foto
      isPanning: false,
      lastPos: {x:0,y:0},
    };

    const canvas = $('#preview');
    const ctx = canvas.getContext('2d');

    // ========= Cargar imagen helpers =========
    function loadImageFromFile(file){
      return new Promise((resolve,reject)=>{
        const reader = new FileReader();
        reader.onload = ()=>{
          const img = new Image();
          // Importante para poder exportar si cargas desde URL externa (CORS)
          img.crossOrigin = 'anonymous';
          img.onload = ()=> resolve(img);
          img.onerror = reject;
          img.src = reader.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function loadImageFromUrl(url){
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = ()=> resolve(img);
        img.onerror = ()=> reject(new Error('No se pudo cargar la imagen (verifica la URL y CORS).'));
        img.src = url;
      });
    }

    // ========= Dibujo =========
    function draw(){
      const S = state.canvasSize;
      ctx.clearRect(0,0,S,S);
      // fondo
      ctx.fillStyle = '#0b1020';
      ctx.fillRect(0,0,S,S);

      // dibujar foto (si hay)
      if(state.photo){
        ctx.save();
        ctx.translate(S/2 + state.offset.x, S/2 + state.offset.y);
        ctx.rotate(state.rotation * Math.PI/180);
        ctx.scale(state.zoom, state.zoom);
        const pw = state.photo.width;
        const ph = state.photo.height;
        const scale = Math.min(S/pw, S/ph); // encajar base
        const dw = pw*scale;
        const dh = ph*scale;
        ctx.drawImage(state.photo, -dw/2, -dh/2, dw, dh);
        ctx.restore();
      }

      // dibujar marco (encima)
      if(state.frame){
        ctx.drawImage(state.frame, 0, 0, S, S);
      }
    }

    // ========= Exportar a 1080 =========
    function exportPNG(){
      const size = state.exportSize;
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const cctx = c.getContext('2d');

      // fondo
      cctx.fillStyle = '#000';
      cctx.fillRect(0,0,size,size);

      // foto
      if(state.photo){
        cctx.save();
        cctx.translate(size/2 + state.offset.x * (size/state.canvasSize), size/2 + state.offset.y * (size/state.canvasSize));
        cctx.rotate(state.rotation * Math.PI/180);
        cctx.scale(state.zoom, state.zoom);
        const pw = state.photo.width, ph=state.photo.height;
        const scale = Math.min(size/pw, size/ph);
        const dw = pw*scale, dh = ph*scale;
        cctx.drawImage(state.photo, -dw/2, -dh/2, dw, dh);
        cctx.restore();
      }
      // marco
      if(state.frame){
        cctx.drawImage(state.frame, 0, 0, size, size);
      }

      const url = c.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'foto-con-marco.png';
      a.click();
    }

    // ========= Ajustes r√°pidos =========
    function fitPhoto(){
      state.zoom = 1; state.rotation = 0; state.offset = {x:0,y:0}; draw();
    }
    function fillPhoto(){
      // aumenta zoom para que no queden bordes negros
      if(!state.photo){return}
      const S = state.canvasSize;
      const pw = state.photo.width, ph = state.photo.height;
      const minScale = Math.max(S/pw, S/ph); // rellenar
      // nuestra base ya encaja con scale=min(S/pw,S/ph) y luego multiplicamos por factor
      // Ajustamos zoom relativo para que fill sea 1.15x por defecto
      state.zoom = Math.max(1, (minScale/Math.min(S/pw,S/ph)) * 1.02);
      state.offset = {x:0,y:0}; state.rotation=0; draw();
    }

    // ========= Interacciones =========
    // Pan con arrastre
    canvas.addEventListener('pointerdown', e=>{
      state.isPanning = true; canvas.setPointerCapture(e.pointerId);
      state.lastPos = {x:e.clientX, y:e.clientY};
    });
    canvas.addEventListener('pointermove', e=>{
      if(!state.isPanning) return;
      const dx = e.clientX - state.lastPos.x;
      const dy = e.clientY - state.lastPos.y;
      state.offset.x += dx; state.offset.y += dy;
      state.lastPos = {x:e.clientX, y:e.clientY};
      draw();
    });
    canvas.addEventListener('pointerup', e=>{ state.isPanning=false; canvas.releasePointerCapture(e.pointerId); });

    // Zoom con rueda
    canvas.addEventListener('wheel', e=>{
      e.preventDefault();
      const delta = -Math.sign(e.deltaY) * 0.06;
      state.zoom = Math.min(4, Math.max(0.2, state.zoom + delta));
      draw();
    }, {passive:false});

    // Gestos t√°ctiles (pinch b√°sico)
    let touchDist = 0;
    canvas.addEventListener('touchstart', e=>{
      if(e.touches.length===2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchDist = Math.hypot(dx,dy);
      }
    }, {passive:true});
    canvas.addEventListener('touchmove', e=>{
      if(e.touches.length===2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const nd = Math.hypot(dx,dy);
        const delta = (nd - touchDist)/250; // factor suave
        state.zoom = Math.min(4, Math.max(0.2, state.zoom + delta));
        touchDist = nd; draw();
      }
    }, {passive:true});

    // Controles
    $('#photoInput').addEventListener('change', async e=>{
      const f = e.target.files?.[0]; if(!f) return;
      state.photo = await loadImageFromFile(f);
      fitPhoto();
    });



    $('#zoomRange').addEventListener('input', e=>{ state.zoom = +e.target.value; draw(); });
    $('#rotateRange').addEventListener('input', e=>{ state.rotation = +e.target.value; draw(); });
    $('#fitBtn').addEventListener('click', fitPhoto);
    $('#fillBtn').addEventListener('click', fillPhoto);
    $('#resetBtn').addEventListener('click', ()=>{
      state.zoom = 1;
      state.rotation = 0;
      state.offset = {x:0, y:0};
      state.photo = null;
      // Limpiar input file
      $('#photoInput').value = '';
      draw();
    });

    $('#downloadBtn').addEventListener('click', ()=>{
      if(!state.photo){ alert('Primero carga una foto.'); return; }
      try{ exportPNG(); } catch(err){ alert('No se pudo exportar.'); }
    });



    // ========= Inicializaci√≥n con par√°metros =========
    async function initFromParams(){
      const title = params.get('title');
      if(title){
        try{ $('#title').textContent = decodeURIComponent(title); }catch{ $('#title').textContent = title; }
      }
      // Siempre usar frame.png como marco predeterminado
      state.frame = await loadImageFromUrl('frame.png');
      draw();
    }

    initFromParams();
  </script>
</body>
</html>